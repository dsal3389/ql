{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>welcome to <code>ql</code>! a simple, light, fast and easy way to implement graphql client in python with the help of <code>pydantic</code>.</p> <p>the library is not intrusive, which means you won't find unexpected attributes and functions attached to you pydantic model, and doesn't change the model behaviour.</p> <p>Note</p> <p>the library does attach methods and properties to your model, but they always in the format of <code>__ql_&lt;..&gt;__</code>, so it is not expected you will ever call them accidentally.</p> simple like it should be<pre><code>import ql\nfrom pydantic import BaseModel\n\n@ql.model  # (1)\nclass Person(BaseModel):\n  first_name: str\n  last_name: str\n  age: int\n\nresponse = ql.raw_query_response_scalar(\"\"\"  (2)\nquery {\n  Person(first_name: \"foo\") {\n    first_name\n    last_name\n    age\n    __typename  # required for scalar\n  }\n}\n\"\"\")\n# {\"person\": Person(first_name=\"foo\", last_name=\"oof\", age=99)}\n</code></pre> <ol> <li>makes the pydantic model compatible to use with the library</li> <li>function that takes a raw query string, send it via http, and scalarize the response base on the <code>__typename</code></li> </ol>"},{"location":"about/","title":"about the library","text":"<p>this library is wrapped around pydantic for easy modeling, typechecking and  because it is pydantic, it is well known package, no need to reinvent the wheel here.</p>"},{"location":"about/#this-library-is-not","title":"this library is not","text":"<ul> <li>an http client library, this library does not implement http communication with graphql endpoints.</li> <li>a graphql server, this library is to create graphql client code.</li> </ul>"},{"location":"about/#this-library-is","title":"this library is","text":"<ul> <li>a light, fast and easy library to work with graphql apis.</li> </ul>"},{"location":"about/#why-use-ql-over-other-libraries","title":"why use <code>ql</code> over other libraries","text":"<p>At the time of writing this library does NOT support <code>mutation</code>, only <code>query</code>.</p> <p>this library was written because when I searched for graphql client libraries, I couldn't find easy/well written libraries for graphql, most of the libraries are small wrappers around <code>requests</code>, or they are trying to reinvent the wheel, and they just feel awkward...</p> <ul> <li> <p><code>simplicity</code> - it is simple to query data, you can provide a query string, or generate a  query string with python objects.</p> </li> <li> <p><code>pydantic</code> - working with a well known library doesn't requires you to learn a lot of new things, also typechecking</p> </li> <li> <p><code>scalar</code> - unlike other libraries, where there is no scalarize ability, or sometimes they require you to  create a <code>Schema</code>, <code>ql</code> library takes use of the <code>__typename</code> field from graphql for scalarize functionality, which means, you don't need to create <code>Schema</code> classes, and it can scalar from any given graphql response as long it includes the <code>__typename</code> field for sub types</p> </li> </ul>"},{"location":"install/","title":"install","text":"pippipenvpoetry <pre><code>pip3 install pydantic-graphql\n</code></pre> <pre><code>pipenv install pydantic-graphql\n</code></pre> <pre><code>poetry add pydantic-graphql\n</code></pre>"},{"location":"api/exceptions/","title":"exceptions","text":"<p>exceptions are only raised in <code>scalar</code> requests, when we convert graphql response to python objects it make sense to convert graphql errors to python exceptions.</p> <p>graphql errors are always the same, if it returned an error you have a problem with your query.</p>"},{"location":"api/exceptions/#qlqlerrorresponseexception","title":"ql.QLErrorResponseException","text":"<p>an exception class that is raised when scalar function gets error response from graphql <pre><code>QLErrorResponseException(errors: list[QueryErrorDict])\n</code></pre></p> Name Type Description <code>errors</code> <code>list[QueryErrorDict]</code> list of graphql errors example.py<pre><code>import ql\n\ntry:\n  _ = ql.scalar_query_response({\n    \"errors\": [\n      {\"message\": \"example for error\", \"locations\": {\"line\": 0, \"column\": 0}},\n      {\"message\": \"I have another error in my query!\", \"locations\": {\"line\": 0, \"column\": 0}},\n    ],\n    \"data\": None\n  })\nexcept ql.QLErrorResponseException:\n  print(\"damn... my graphql query failed...\")\n</code></pre>"},{"location":"api/exceptions/#error_details-property","title":"error_details <code>property</code>","text":"<p>returns a list of <code>QLErrorDetails</code>.</p>"},{"location":"api/exceptions/#qlqlerrordetails","title":"ql.QLErrorDetails","text":"<p>class used to map each error detail to python object <pre><code>QLErrorDetails(message: str, locations: list[QueryErrorLocationDict])\n</code></pre></p> Name Type Description <code>message</code> <code>str</code> the message field from the graphql error <code>locations</code> <code>list[QueryErrorLocationDict]</code> list of locations where the error occurse"},{"location":"api/http/","title":"http","text":"<p>this library does not implement http communication with graphql server since API can be different from implementation to implementation. the library http client accept a <code>request</code> function that takes a graphql query string, and returns the json response parsed as dict, this allows  the flexability to implement error handlers in the passed request function instead of wrapping each <code>query</code> request with <code>try...except</code>.</p>"},{"location":"api/http/#qlhttpset_request_func","title":"ql.http.set_request_func","text":"<p>set request function for the <code>ql</code> client <pre><code>def set_request_func(request_func: GraphqlRequestFunc) -&gt; None:\n</code></pre></p> Name Type Description <code>request_func</code> <code>GraphqlRequestFunc</code> callable function that accepts a string and returns dict example.py<pre><code>import ql\nimport requests\n\ndef request_graphql(query: str) -&gt; dict:\n  response = requests.post(\"...\", json={\"query\": query})\n  response.raise_for_status()  # can handle errors here in one place\n  return response.json()\n\nql.http.set_request_func(request_graphql)\n</code></pre>"},{"location":"api/http/#qlhttprequest","title":"ql.http.request","text":"<p>send request query with given request function <pre><code>def request(self, query: str) -&gt; QueryResponseDict:\n</code></pre></p> Name Type Description <code>query</code> <code>str</code> the query request that will be passed to the function"},{"location":"api/model/","title":"model","text":""},{"location":"api/model/#qlall_models","title":"ql.all_models","text":"<p>returns a dict mapping between all registered models and thier  registered typename</p> <pre><code>def all_models() -&gt; dict[str, type[BaseModel]]:\n</code></pre>"},{"location":"api/model/#qltypename","title":"ql.typename","text":"<p>returns the model configured typename, if model is not registered with <code>ql.model</code> then return <code>None</code></p> <pre><code>def typename(model: type[BaseModel]) -&gt; Optional[str]:\n</code></pre> Name Type Description <code>model</code> <code>type[BaseModel]</code> the model we want the typename for"},{"location":"api/model/#qlimplements","title":"ql.implements","text":"<p>returns all child models, that the given model implements</p> <pre><code>def implements(cls: type[BaseModel]) -&gt; tuple\n</code></pre> Name Type Description <code>cls</code> <code>type[BaseModel]</code> the model we want to take implementations from <pre><code>import ql\nfrom pydantic import BaseModel\n\n\n@lq.model\nclass Human(BaseModel):\n    first_name: str\n    last_name: str\n\n\n@ql.model\nclass Male(Human):\n    pass\n\n\n@ql.model\nclass Female(Human):\n    pass\n\n\nprint(ql.implements(Human))\n# (&lt;class '__main__.Male'&gt;, &lt;class '__main__.Female'&gt;)\n</code></pre>"},{"location":"api/model/#qlquery_fields_nt","title":"ql.query_fields_nt","text":"<p>returns a namedtuple of all queryable fields in the given model, mapping between the model field name to the query name.</p> <p>Info</p> <p>this function is also aliased as <code>ql._</code> because it is common</p> <pre><code>def query_fields_nt(cls: type[BaseModel]) -&gt; Any\n</code></pre> Name Type Description <code>cls</code> <code>type[BaseModel]</code> the model we want the namedtuple from <pre><code>import ql\nfrom typing import Annotated\nfrom pydantic import BaseModel\n\n\n@ql.model\nclass Article(BaseModel):\n    name: Annotated[str, ql.metadata(query_name=\"title\")]\n    description: str\n\n    foo: Annotated[str, ql.metadata(queryable=False)]\n\nprint(ql.query_fields_nt(Article).name)         # \"title\"\nprint(ql.query_fields_nt(Article).description)  # \"description\"\nprint(ql.query_fields_nt(Article).foo)          # exception\n</code></pre>"},{"location":"api/query/","title":"query","text":"<p>reading data from apis is the most common operation we do, that's why <code>ql</code> makes it  easy to query data from your graphql endpoint and provide variety of query methods.</p>"},{"location":"api/query/#qlquery","title":"ql.query","text":"<p>takes python ql query structure and returns a valid graphql query string. <pre><code>def query(\n    *query_models: _QueryModelType,\n    fragments: Optional[_QueryFragmentType] = None,\n    include_typename: bool = True,\n) -&gt; str:\n</code></pre></p> Name Type Description <code>query_models</code> <code>*_QueryModelType</code> python ql structured query <code>fragments</code> <code>Optional[_QueryFragmentType]</code> dict mapping between <code>ql.fragment</code> to the python ql structured query <code>include_typename</code> <code>bool</code> if include <code>__typename</code> field when querying sub types example.py<pre><code>import ql\nfrom pydantic import BaseModel\n\n@ql.model\nclass Point(BaseModel):\n  x: int\n  y: int\n\nquery_str = ql.query(\n  (Point, (\n    ql._(Point).x,\n    ql._(Point).y\n  ))\n)\n</code></pre>"},{"location":"api/query/#qlquery_response","title":"ql.query_response","text":"<p>serializes the ql query structure, send it via http and returns the response as <code>dict</code>. <pre><code>def query_response(\n    *query_models: _QueryModelType,\n    fragments: Optional[_QueryFragmentType] = {},\n    include_typename: bool = True,\n) -&gt; QueryResponseDict:\n</code></pre></p> <p>http request function must be set to make this function work, click here to view.</p>"},{"location":"api/query/#qlquery_response_scalar","title":"ql.query_response_scalar","text":"<p>serializes the ql query structure to a valid graphql query, send it via http, takes the response and returns a scalared dict with the defined models, this function will also raise graphql errors if the query responsed with <code>errors</code> field <pre><code>def query_response_scalar(\n    *query_models: _QueryModelType, fragments: Optional[_QueryFragmentType] = None\n) -&gt; dict[str, BaseModel | list[BaseModel]]:\n</code></pre></p>"},{"location":"examples/","title":"EXAMPLES","text":"<p>it is easier to brief though the examples and see what this library can provide and most importantly, how it provides the functionalities.</p> <p>the examples don't cover all use cases but they should give  you an idea of how to use the library.</p>"},{"location":"examples/query/","title":"Query examples","text":"raw query<pre><code>import ql\nimport requests\n\ndef graphql_request(query: str) -&gt; dict:\n  response = requests.post(\"...\", json={\"query\": query})\n  response.raise_status_code()\n  return response.json()\n\nql.http.set_request_func(graphql_request)\n\ngraphql_response = ql.raw_query_response(\"\"\"\n  query {\n    Person {\n      name\n      age\n    }\n  }\n\"\"\")\n</code></pre> raw query scalar response<pre><code>import ql\nimport requests\nfrom pydantic import BaseModel\n\ndef graphql_request(query: str) -&gt; dict:\n  response = requests.post(\"...\", json={\"query\": query})\n  response.raise_status_code()\n  return response.json()\n\nql.http.set_request_func(graphql_request)\n\n@ql.model\nclass Point(BaseModel):\n  x: int\n  y: int\n\nquery_response = ql.raw_query_response_scalar(\"\"\"\n  query {\n    Point {\n      x\n      y\n      __typename\n    }\n  }\n\"\"\")\n# {\"point\": [Point(x=5, y=5), Point(x=0, y=-5)]}\n</code></pre> python query structure to string<pre><code>import ql\nfrom pydantic import BaseModel\n\n\n@ql.model\nclass Human(BaseModel):\n  name: str\n  age: int\n\n\n@ql.model\nclass Female(Human):\n  is_pregnant: bool\n\n\n@ql.model\nclass Male(Human):\n  working: bool\n\n\nquery_str = ql.query(\n  (Human, (\n    ql._(Human).name,\n    ql._(Human).age\n  )),\n)\n# query{Human{name,age,__typename}}\n\n\nquery_str2 = ql.query(\n  (Human, (\n    ql._(Human).name,\n    (ql.on(Female), (\n      ql._(Female).is_pregnant,\n    )),\n    (ql.on(Male), (\n      ql._(Male).working,\n    )),\n  ))\n)\n# query{Human{name,...on Female{is_pregnant,__typename},...on Male{working,__typename},__typename}}\n</code></pre>"},{"location":"tutorial/model/","title":"model","text":"<p>modeling your graphql types is done with <code>pydantic</code>, and making the model compatible with the <code>ql</code> library, use <code>lq.model</code></p>"},{"location":"tutorial/model/#what-qlmodel-does-exactly","title":"what <code>ql.model</code> does exactly?","text":"<p>this decorator defines couple of attributes that are required for graphql apis and are used across the library.</p> Name Type Description <code>__ql_query_name__</code> <code>str</code> the model query name in graphql <code>__ql_typename__</code> <code>str</code> the model <code>__typename</code> as it is in the graphql api, this will help us scalar responses <code>__ql_implements__</code> <code>dict[str, type[BaseModel]]</code> inheriting models will register themselves the parents <code>__ql_implements__</code> <code>__ql_query_fields_nt__</code> <code>NamedTuple</code> returns a named tuple with all queryable fields, the name tuple maps between the field to the graphql field name based on the <code>ql.metadata</code> attached to the field"},{"location":"tutorial/query/","title":"query","text":"<p>querying is the most common operation, <code>ql</code> provides couple of ways to query your data.</p>"},{"location":"tutorial/query/#raw-query","title":"raw query","text":"<p>raw querying just accepts your query string, as is, query functions that accept raw query, are usally prefixed with <code>raw_</code></p> example<pre><code>import ql\n\nresponse = ql.raw_query_response(\"\"\"\nquery {\n    people {\n        name\n        age\n    }\n}\n\"\"\")\n</code></pre>"},{"location":"tutorial/query/#query-python-schema","title":"query python schema","text":"<p><code>ql</code> also can takes a tuple of 2 values, value at index <code>0</code> is the model type,  value at index <code>1</code> is the fields we want to take from the model.</p> <pre><code>(&lt;model&gt;, (\n    field, \n    field, \n    field, \n    ...\n))\n</code></pre> <p>in code the query schema will look something like this <pre><code>import ql\nfrom pydantic import BaseModel\n\n\n@ql.model\nclass Person(BaseModel):\n    name: str\n    age: int\n\n\nquery_str = ql.query(\n    (Person, (\n        ql._(Person).name,\n        ql._(Person).age\n    ))\n)\n</code></pre></p> <p>the <code>ql._</code> function</p> <p>we wrap the model <code>Person</code> inside <code>ql._</code> to get the correct field queryname, more information about this function click here</p> <p>NOTICE that the <code>query</code> function and all other query functions that accept python query schema takes  tuple, and the can take multiple tuples to query multiple graphql types</p> <pre><code>query_str = ql.query(\n    (ModelA, (\n        ql._(ModelA).foo,\n        ...\n    )),\n    (ModelB, (\n        ql._(ModelB).foo,\n        ...\n    )),\n    ...\n)\n</code></pre>"},{"location":"tutorial/query/#nested-fields","title":"nested fields","text":"<p>lets first look at an example of querying nested fields <pre><code>import ql\nfrom pydantic import BaseModel\n\n\n@ql.model\nclass Child(BaseModel):\n    name: str\n    sleeps: bool\n\n\n@ql.model\nclass Person(BaseModel):\n    name: str\n    age: int\n    child: Child\n\n\nquery_str = ql.query(\n    (Person, (\n        ql._(Person).name,\n        ql._(Person).age,\n        (ql._(Person).child, (\n            ql._(Child).name,\n            ql._(Child).sleeps\n        )),\n    ))\n)\n</code></pre></p> <p>looks a bit more complicated. the nested schema is the same schema as before, but in the nested tuple at index <code>0</code> we don't provide the model, we provide the <code>ql._(Person).child</code> field instead.</p> <p>we can keep nesting like that as much as we want. <pre><code>(&lt;model&gt;, (\n    field,\n    field, \n    field,\n    (field, (\n        field,\n        field,\n        (field, (\n            field,\n            field,\n            ...\n        ))\n    ))\n))\n</code></pre></p>"}]}